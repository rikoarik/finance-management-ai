// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'recurring_event.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
  'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models',
);

/// @nodoc
mixin _$RecurringEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadRecurring,
    required TResult Function(RecurringTransaction recurring) addRecurring,
    required TResult Function(RecurringTransaction recurring) updateRecurring,
    required TResult Function(String id) deleteRecurring,
    required TResult Function(String id, bool isActive) toggleActive,
    required TResult Function() processRecurring,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadRecurring,
    TResult? Function(RecurringTransaction recurring)? addRecurring,
    TResult? Function(RecurringTransaction recurring)? updateRecurring,
    TResult? Function(String id)? deleteRecurring,
    TResult? Function(String id, bool isActive)? toggleActive,
    TResult? Function()? processRecurring,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadRecurring,
    TResult Function(RecurringTransaction recurring)? addRecurring,
    TResult Function(RecurringTransaction recurring)? updateRecurring,
    TResult Function(String id)? deleteRecurring,
    TResult Function(String id, bool isActive)? toggleActive,
    TResult Function()? processRecurring,
    required TResult orElse(),
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoadRecurring value) loadRecurring,
    required TResult Function(AddRecurring value) addRecurring,
    required TResult Function(UpdateRecurring value) updateRecurring,
    required TResult Function(DeleteRecurring value) deleteRecurring,
    required TResult Function(ToggleActive value) toggleActive,
    required TResult Function(ProcessRecurring value) processRecurring,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LoadRecurring value)? loadRecurring,
    TResult? Function(AddRecurring value)? addRecurring,
    TResult? Function(UpdateRecurring value)? updateRecurring,
    TResult? Function(DeleteRecurring value)? deleteRecurring,
    TResult? Function(ToggleActive value)? toggleActive,
    TResult? Function(ProcessRecurring value)? processRecurring,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoadRecurring value)? loadRecurring,
    TResult Function(AddRecurring value)? addRecurring,
    TResult Function(UpdateRecurring value)? updateRecurring,
    TResult Function(DeleteRecurring value)? deleteRecurring,
    TResult Function(ToggleActive value)? toggleActive,
    TResult Function(ProcessRecurring value)? processRecurring,
    required TResult orElse(),
  }) => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RecurringEventCopyWith<$Res> {
  factory $RecurringEventCopyWith(
    RecurringEvent value,
    $Res Function(RecurringEvent) then,
  ) = _$RecurringEventCopyWithImpl<$Res, RecurringEvent>;
}

/// @nodoc
class _$RecurringEventCopyWithImpl<$Res, $Val extends RecurringEvent>
    implements $RecurringEventCopyWith<$Res> {
  _$RecurringEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of RecurringEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$LoadRecurringImplCopyWith<$Res> {
  factory _$$LoadRecurringImplCopyWith(
    _$LoadRecurringImpl value,
    $Res Function(_$LoadRecurringImpl) then,
  ) = __$$LoadRecurringImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadRecurringImplCopyWithImpl<$Res>
    extends _$RecurringEventCopyWithImpl<$Res, _$LoadRecurringImpl>
    implements _$$LoadRecurringImplCopyWith<$Res> {
  __$$LoadRecurringImplCopyWithImpl(
    _$LoadRecurringImpl _value,
    $Res Function(_$LoadRecurringImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of RecurringEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$LoadRecurringImpl implements LoadRecurring {
  const _$LoadRecurringImpl();

  @override
  String toString() {
    return 'RecurringEvent.loadRecurring()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LoadRecurringImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadRecurring,
    required TResult Function(RecurringTransaction recurring) addRecurring,
    required TResult Function(RecurringTransaction recurring) updateRecurring,
    required TResult Function(String id) deleteRecurring,
    required TResult Function(String id, bool isActive) toggleActive,
    required TResult Function() processRecurring,
  }) {
    return loadRecurring();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadRecurring,
    TResult? Function(RecurringTransaction recurring)? addRecurring,
    TResult? Function(RecurringTransaction recurring)? updateRecurring,
    TResult? Function(String id)? deleteRecurring,
    TResult? Function(String id, bool isActive)? toggleActive,
    TResult? Function()? processRecurring,
  }) {
    return loadRecurring?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadRecurring,
    TResult Function(RecurringTransaction recurring)? addRecurring,
    TResult Function(RecurringTransaction recurring)? updateRecurring,
    TResult Function(String id)? deleteRecurring,
    TResult Function(String id, bool isActive)? toggleActive,
    TResult Function()? processRecurring,
    required TResult orElse(),
  }) {
    if (loadRecurring != null) {
      return loadRecurring();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoadRecurring value) loadRecurring,
    required TResult Function(AddRecurring value) addRecurring,
    required TResult Function(UpdateRecurring value) updateRecurring,
    required TResult Function(DeleteRecurring value) deleteRecurring,
    required TResult Function(ToggleActive value) toggleActive,
    required TResult Function(ProcessRecurring value) processRecurring,
  }) {
    return loadRecurring(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LoadRecurring value)? loadRecurring,
    TResult? Function(AddRecurring value)? addRecurring,
    TResult? Function(UpdateRecurring value)? updateRecurring,
    TResult? Function(DeleteRecurring value)? deleteRecurring,
    TResult? Function(ToggleActive value)? toggleActive,
    TResult? Function(ProcessRecurring value)? processRecurring,
  }) {
    return loadRecurring?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoadRecurring value)? loadRecurring,
    TResult Function(AddRecurring value)? addRecurring,
    TResult Function(UpdateRecurring value)? updateRecurring,
    TResult Function(DeleteRecurring value)? deleteRecurring,
    TResult Function(ToggleActive value)? toggleActive,
    TResult Function(ProcessRecurring value)? processRecurring,
    required TResult orElse(),
  }) {
    if (loadRecurring != null) {
      return loadRecurring(this);
    }
    return orElse();
  }
}

abstract class LoadRecurring implements RecurringEvent {
  const factory LoadRecurring() = _$LoadRecurringImpl;
}

/// @nodoc
abstract class _$$AddRecurringImplCopyWith<$Res> {
  factory _$$AddRecurringImplCopyWith(
    _$AddRecurringImpl value,
    $Res Function(_$AddRecurringImpl) then,
  ) = __$$AddRecurringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({RecurringTransaction recurring});
}

/// @nodoc
class __$$AddRecurringImplCopyWithImpl<$Res>
    extends _$RecurringEventCopyWithImpl<$Res, _$AddRecurringImpl>
    implements _$$AddRecurringImplCopyWith<$Res> {
  __$$AddRecurringImplCopyWithImpl(
    _$AddRecurringImpl _value,
    $Res Function(_$AddRecurringImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of RecurringEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? recurring = null}) {
    return _then(
      _$AddRecurringImpl(
        null == recurring
            ? _value.recurring
            : recurring // ignore: cast_nullable_to_non_nullable
                  as RecurringTransaction,
      ),
    );
  }
}

/// @nodoc

class _$AddRecurringImpl implements AddRecurring {
  const _$AddRecurringImpl(this.recurring);

  @override
  final RecurringTransaction recurring;

  @override
  String toString() {
    return 'RecurringEvent.addRecurring(recurring: $recurring)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddRecurringImpl &&
            (identical(other.recurring, recurring) ||
                other.recurring == recurring));
  }

  @override
  int get hashCode => Object.hash(runtimeType, recurring);

  /// Create a copy of RecurringEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AddRecurringImplCopyWith<_$AddRecurringImpl> get copyWith =>
      __$$AddRecurringImplCopyWithImpl<_$AddRecurringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadRecurring,
    required TResult Function(RecurringTransaction recurring) addRecurring,
    required TResult Function(RecurringTransaction recurring) updateRecurring,
    required TResult Function(String id) deleteRecurring,
    required TResult Function(String id, bool isActive) toggleActive,
    required TResult Function() processRecurring,
  }) {
    return addRecurring(recurring);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadRecurring,
    TResult? Function(RecurringTransaction recurring)? addRecurring,
    TResult? Function(RecurringTransaction recurring)? updateRecurring,
    TResult? Function(String id)? deleteRecurring,
    TResult? Function(String id, bool isActive)? toggleActive,
    TResult? Function()? processRecurring,
  }) {
    return addRecurring?.call(recurring);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadRecurring,
    TResult Function(RecurringTransaction recurring)? addRecurring,
    TResult Function(RecurringTransaction recurring)? updateRecurring,
    TResult Function(String id)? deleteRecurring,
    TResult Function(String id, bool isActive)? toggleActive,
    TResult Function()? processRecurring,
    required TResult orElse(),
  }) {
    if (addRecurring != null) {
      return addRecurring(recurring);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoadRecurring value) loadRecurring,
    required TResult Function(AddRecurring value) addRecurring,
    required TResult Function(UpdateRecurring value) updateRecurring,
    required TResult Function(DeleteRecurring value) deleteRecurring,
    required TResult Function(ToggleActive value) toggleActive,
    required TResult Function(ProcessRecurring value) processRecurring,
  }) {
    return addRecurring(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LoadRecurring value)? loadRecurring,
    TResult? Function(AddRecurring value)? addRecurring,
    TResult? Function(UpdateRecurring value)? updateRecurring,
    TResult? Function(DeleteRecurring value)? deleteRecurring,
    TResult? Function(ToggleActive value)? toggleActive,
    TResult? Function(ProcessRecurring value)? processRecurring,
  }) {
    return addRecurring?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoadRecurring value)? loadRecurring,
    TResult Function(AddRecurring value)? addRecurring,
    TResult Function(UpdateRecurring value)? updateRecurring,
    TResult Function(DeleteRecurring value)? deleteRecurring,
    TResult Function(ToggleActive value)? toggleActive,
    TResult Function(ProcessRecurring value)? processRecurring,
    required TResult orElse(),
  }) {
    if (addRecurring != null) {
      return addRecurring(this);
    }
    return orElse();
  }
}

abstract class AddRecurring implements RecurringEvent {
  const factory AddRecurring(final RecurringTransaction recurring) =
      _$AddRecurringImpl;

  RecurringTransaction get recurring;

  /// Create a copy of RecurringEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AddRecurringImplCopyWith<_$AddRecurringImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UpdateRecurringImplCopyWith<$Res> {
  factory _$$UpdateRecurringImplCopyWith(
    _$UpdateRecurringImpl value,
    $Res Function(_$UpdateRecurringImpl) then,
  ) = __$$UpdateRecurringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({RecurringTransaction recurring});
}

/// @nodoc
class __$$UpdateRecurringImplCopyWithImpl<$Res>
    extends _$RecurringEventCopyWithImpl<$Res, _$UpdateRecurringImpl>
    implements _$$UpdateRecurringImplCopyWith<$Res> {
  __$$UpdateRecurringImplCopyWithImpl(
    _$UpdateRecurringImpl _value,
    $Res Function(_$UpdateRecurringImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of RecurringEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? recurring = null}) {
    return _then(
      _$UpdateRecurringImpl(
        null == recurring
            ? _value.recurring
            : recurring // ignore: cast_nullable_to_non_nullable
                  as RecurringTransaction,
      ),
    );
  }
}

/// @nodoc

class _$UpdateRecurringImpl implements UpdateRecurring {
  const _$UpdateRecurringImpl(this.recurring);

  @override
  final RecurringTransaction recurring;

  @override
  String toString() {
    return 'RecurringEvent.updateRecurring(recurring: $recurring)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UpdateRecurringImpl &&
            (identical(other.recurring, recurring) ||
                other.recurring == recurring));
  }

  @override
  int get hashCode => Object.hash(runtimeType, recurring);

  /// Create a copy of RecurringEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$UpdateRecurringImplCopyWith<_$UpdateRecurringImpl> get copyWith =>
      __$$UpdateRecurringImplCopyWithImpl<_$UpdateRecurringImpl>(
        this,
        _$identity,
      );

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadRecurring,
    required TResult Function(RecurringTransaction recurring) addRecurring,
    required TResult Function(RecurringTransaction recurring) updateRecurring,
    required TResult Function(String id) deleteRecurring,
    required TResult Function(String id, bool isActive) toggleActive,
    required TResult Function() processRecurring,
  }) {
    return updateRecurring(recurring);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadRecurring,
    TResult? Function(RecurringTransaction recurring)? addRecurring,
    TResult? Function(RecurringTransaction recurring)? updateRecurring,
    TResult? Function(String id)? deleteRecurring,
    TResult? Function(String id, bool isActive)? toggleActive,
    TResult? Function()? processRecurring,
  }) {
    return updateRecurring?.call(recurring);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadRecurring,
    TResult Function(RecurringTransaction recurring)? addRecurring,
    TResult Function(RecurringTransaction recurring)? updateRecurring,
    TResult Function(String id)? deleteRecurring,
    TResult Function(String id, bool isActive)? toggleActive,
    TResult Function()? processRecurring,
    required TResult orElse(),
  }) {
    if (updateRecurring != null) {
      return updateRecurring(recurring);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoadRecurring value) loadRecurring,
    required TResult Function(AddRecurring value) addRecurring,
    required TResult Function(UpdateRecurring value) updateRecurring,
    required TResult Function(DeleteRecurring value) deleteRecurring,
    required TResult Function(ToggleActive value) toggleActive,
    required TResult Function(ProcessRecurring value) processRecurring,
  }) {
    return updateRecurring(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LoadRecurring value)? loadRecurring,
    TResult? Function(AddRecurring value)? addRecurring,
    TResult? Function(UpdateRecurring value)? updateRecurring,
    TResult? Function(DeleteRecurring value)? deleteRecurring,
    TResult? Function(ToggleActive value)? toggleActive,
    TResult? Function(ProcessRecurring value)? processRecurring,
  }) {
    return updateRecurring?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoadRecurring value)? loadRecurring,
    TResult Function(AddRecurring value)? addRecurring,
    TResult Function(UpdateRecurring value)? updateRecurring,
    TResult Function(DeleteRecurring value)? deleteRecurring,
    TResult Function(ToggleActive value)? toggleActive,
    TResult Function(ProcessRecurring value)? processRecurring,
    required TResult orElse(),
  }) {
    if (updateRecurring != null) {
      return updateRecurring(this);
    }
    return orElse();
  }
}

abstract class UpdateRecurring implements RecurringEvent {
  const factory UpdateRecurring(final RecurringTransaction recurring) =
      _$UpdateRecurringImpl;

  RecurringTransaction get recurring;

  /// Create a copy of RecurringEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$UpdateRecurringImplCopyWith<_$UpdateRecurringImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DeleteRecurringImplCopyWith<$Res> {
  factory _$$DeleteRecurringImplCopyWith(
    _$DeleteRecurringImpl value,
    $Res Function(_$DeleteRecurringImpl) then,
  ) = __$$DeleteRecurringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String id});
}

/// @nodoc
class __$$DeleteRecurringImplCopyWithImpl<$Res>
    extends _$RecurringEventCopyWithImpl<$Res, _$DeleteRecurringImpl>
    implements _$$DeleteRecurringImplCopyWith<$Res> {
  __$$DeleteRecurringImplCopyWithImpl(
    _$DeleteRecurringImpl _value,
    $Res Function(_$DeleteRecurringImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of RecurringEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? id = null}) {
    return _then(
      _$DeleteRecurringImpl(
        null == id
            ? _value.id
            : id // ignore: cast_nullable_to_non_nullable
                  as String,
      ),
    );
  }
}

/// @nodoc

class _$DeleteRecurringImpl implements DeleteRecurring {
  const _$DeleteRecurringImpl(this.id);

  @override
  final String id;

  @override
  String toString() {
    return 'RecurringEvent.deleteRecurring(id: $id)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DeleteRecurringImpl &&
            (identical(other.id, id) || other.id == id));
  }

  @override
  int get hashCode => Object.hash(runtimeType, id);

  /// Create a copy of RecurringEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$DeleteRecurringImplCopyWith<_$DeleteRecurringImpl> get copyWith =>
      __$$DeleteRecurringImplCopyWithImpl<_$DeleteRecurringImpl>(
        this,
        _$identity,
      );

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadRecurring,
    required TResult Function(RecurringTransaction recurring) addRecurring,
    required TResult Function(RecurringTransaction recurring) updateRecurring,
    required TResult Function(String id) deleteRecurring,
    required TResult Function(String id, bool isActive) toggleActive,
    required TResult Function() processRecurring,
  }) {
    return deleteRecurring(id);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadRecurring,
    TResult? Function(RecurringTransaction recurring)? addRecurring,
    TResult? Function(RecurringTransaction recurring)? updateRecurring,
    TResult? Function(String id)? deleteRecurring,
    TResult? Function(String id, bool isActive)? toggleActive,
    TResult? Function()? processRecurring,
  }) {
    return deleteRecurring?.call(id);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadRecurring,
    TResult Function(RecurringTransaction recurring)? addRecurring,
    TResult Function(RecurringTransaction recurring)? updateRecurring,
    TResult Function(String id)? deleteRecurring,
    TResult Function(String id, bool isActive)? toggleActive,
    TResult Function()? processRecurring,
    required TResult orElse(),
  }) {
    if (deleteRecurring != null) {
      return deleteRecurring(id);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoadRecurring value) loadRecurring,
    required TResult Function(AddRecurring value) addRecurring,
    required TResult Function(UpdateRecurring value) updateRecurring,
    required TResult Function(DeleteRecurring value) deleteRecurring,
    required TResult Function(ToggleActive value) toggleActive,
    required TResult Function(ProcessRecurring value) processRecurring,
  }) {
    return deleteRecurring(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LoadRecurring value)? loadRecurring,
    TResult? Function(AddRecurring value)? addRecurring,
    TResult? Function(UpdateRecurring value)? updateRecurring,
    TResult? Function(DeleteRecurring value)? deleteRecurring,
    TResult? Function(ToggleActive value)? toggleActive,
    TResult? Function(ProcessRecurring value)? processRecurring,
  }) {
    return deleteRecurring?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoadRecurring value)? loadRecurring,
    TResult Function(AddRecurring value)? addRecurring,
    TResult Function(UpdateRecurring value)? updateRecurring,
    TResult Function(DeleteRecurring value)? deleteRecurring,
    TResult Function(ToggleActive value)? toggleActive,
    TResult Function(ProcessRecurring value)? processRecurring,
    required TResult orElse(),
  }) {
    if (deleteRecurring != null) {
      return deleteRecurring(this);
    }
    return orElse();
  }
}

abstract class DeleteRecurring implements RecurringEvent {
  const factory DeleteRecurring(final String id) = _$DeleteRecurringImpl;

  String get id;

  /// Create a copy of RecurringEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$DeleteRecurringImplCopyWith<_$DeleteRecurringImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ToggleActiveImplCopyWith<$Res> {
  factory _$$ToggleActiveImplCopyWith(
    _$ToggleActiveImpl value,
    $Res Function(_$ToggleActiveImpl) then,
  ) = __$$ToggleActiveImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String id, bool isActive});
}

/// @nodoc
class __$$ToggleActiveImplCopyWithImpl<$Res>
    extends _$RecurringEventCopyWithImpl<$Res, _$ToggleActiveImpl>
    implements _$$ToggleActiveImplCopyWith<$Res> {
  __$$ToggleActiveImplCopyWithImpl(
    _$ToggleActiveImpl _value,
    $Res Function(_$ToggleActiveImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of RecurringEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? id = null, Object? isActive = null}) {
    return _then(
      _$ToggleActiveImpl(
        null == id
            ? _value.id
            : id // ignore: cast_nullable_to_non_nullable
                  as String,
        null == isActive
            ? _value.isActive
            : isActive // ignore: cast_nullable_to_non_nullable
                  as bool,
      ),
    );
  }
}

/// @nodoc

class _$ToggleActiveImpl implements ToggleActive {
  const _$ToggleActiveImpl(this.id, this.isActive);

  @override
  final String id;
  @override
  final bool isActive;

  @override
  String toString() {
    return 'RecurringEvent.toggleActive(id: $id, isActive: $isActive)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ToggleActiveImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.isActive, isActive) ||
                other.isActive == isActive));
  }

  @override
  int get hashCode => Object.hash(runtimeType, id, isActive);

  /// Create a copy of RecurringEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ToggleActiveImplCopyWith<_$ToggleActiveImpl> get copyWith =>
      __$$ToggleActiveImplCopyWithImpl<_$ToggleActiveImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadRecurring,
    required TResult Function(RecurringTransaction recurring) addRecurring,
    required TResult Function(RecurringTransaction recurring) updateRecurring,
    required TResult Function(String id) deleteRecurring,
    required TResult Function(String id, bool isActive) toggleActive,
    required TResult Function() processRecurring,
  }) {
    return toggleActive(id, isActive);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadRecurring,
    TResult? Function(RecurringTransaction recurring)? addRecurring,
    TResult? Function(RecurringTransaction recurring)? updateRecurring,
    TResult? Function(String id)? deleteRecurring,
    TResult? Function(String id, bool isActive)? toggleActive,
    TResult? Function()? processRecurring,
  }) {
    return toggleActive?.call(id, isActive);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadRecurring,
    TResult Function(RecurringTransaction recurring)? addRecurring,
    TResult Function(RecurringTransaction recurring)? updateRecurring,
    TResult Function(String id)? deleteRecurring,
    TResult Function(String id, bool isActive)? toggleActive,
    TResult Function()? processRecurring,
    required TResult orElse(),
  }) {
    if (toggleActive != null) {
      return toggleActive(id, isActive);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoadRecurring value) loadRecurring,
    required TResult Function(AddRecurring value) addRecurring,
    required TResult Function(UpdateRecurring value) updateRecurring,
    required TResult Function(DeleteRecurring value) deleteRecurring,
    required TResult Function(ToggleActive value) toggleActive,
    required TResult Function(ProcessRecurring value) processRecurring,
  }) {
    return toggleActive(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LoadRecurring value)? loadRecurring,
    TResult? Function(AddRecurring value)? addRecurring,
    TResult? Function(UpdateRecurring value)? updateRecurring,
    TResult? Function(DeleteRecurring value)? deleteRecurring,
    TResult? Function(ToggleActive value)? toggleActive,
    TResult? Function(ProcessRecurring value)? processRecurring,
  }) {
    return toggleActive?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoadRecurring value)? loadRecurring,
    TResult Function(AddRecurring value)? addRecurring,
    TResult Function(UpdateRecurring value)? updateRecurring,
    TResult Function(DeleteRecurring value)? deleteRecurring,
    TResult Function(ToggleActive value)? toggleActive,
    TResult Function(ProcessRecurring value)? processRecurring,
    required TResult orElse(),
  }) {
    if (toggleActive != null) {
      return toggleActive(this);
    }
    return orElse();
  }
}

abstract class ToggleActive implements RecurringEvent {
  const factory ToggleActive(final String id, final bool isActive) =
      _$ToggleActiveImpl;

  String get id;
  bool get isActive;

  /// Create a copy of RecurringEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ToggleActiveImplCopyWith<_$ToggleActiveImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ProcessRecurringImplCopyWith<$Res> {
  factory _$$ProcessRecurringImplCopyWith(
    _$ProcessRecurringImpl value,
    $Res Function(_$ProcessRecurringImpl) then,
  ) = __$$ProcessRecurringImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ProcessRecurringImplCopyWithImpl<$Res>
    extends _$RecurringEventCopyWithImpl<$Res, _$ProcessRecurringImpl>
    implements _$$ProcessRecurringImplCopyWith<$Res> {
  __$$ProcessRecurringImplCopyWithImpl(
    _$ProcessRecurringImpl _value,
    $Res Function(_$ProcessRecurringImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of RecurringEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$ProcessRecurringImpl implements ProcessRecurring {
  const _$ProcessRecurringImpl();

  @override
  String toString() {
    return 'RecurringEvent.processRecurring()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ProcessRecurringImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadRecurring,
    required TResult Function(RecurringTransaction recurring) addRecurring,
    required TResult Function(RecurringTransaction recurring) updateRecurring,
    required TResult Function(String id) deleteRecurring,
    required TResult Function(String id, bool isActive) toggleActive,
    required TResult Function() processRecurring,
  }) {
    return processRecurring();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadRecurring,
    TResult? Function(RecurringTransaction recurring)? addRecurring,
    TResult? Function(RecurringTransaction recurring)? updateRecurring,
    TResult? Function(String id)? deleteRecurring,
    TResult? Function(String id, bool isActive)? toggleActive,
    TResult? Function()? processRecurring,
  }) {
    return processRecurring?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadRecurring,
    TResult Function(RecurringTransaction recurring)? addRecurring,
    TResult Function(RecurringTransaction recurring)? updateRecurring,
    TResult Function(String id)? deleteRecurring,
    TResult Function(String id, bool isActive)? toggleActive,
    TResult Function()? processRecurring,
    required TResult orElse(),
  }) {
    if (processRecurring != null) {
      return processRecurring();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoadRecurring value) loadRecurring,
    required TResult Function(AddRecurring value) addRecurring,
    required TResult Function(UpdateRecurring value) updateRecurring,
    required TResult Function(DeleteRecurring value) deleteRecurring,
    required TResult Function(ToggleActive value) toggleActive,
    required TResult Function(ProcessRecurring value) processRecurring,
  }) {
    return processRecurring(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LoadRecurring value)? loadRecurring,
    TResult? Function(AddRecurring value)? addRecurring,
    TResult? Function(UpdateRecurring value)? updateRecurring,
    TResult? Function(DeleteRecurring value)? deleteRecurring,
    TResult? Function(ToggleActive value)? toggleActive,
    TResult? Function(ProcessRecurring value)? processRecurring,
  }) {
    return processRecurring?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoadRecurring value)? loadRecurring,
    TResult Function(AddRecurring value)? addRecurring,
    TResult Function(UpdateRecurring value)? updateRecurring,
    TResult Function(DeleteRecurring value)? deleteRecurring,
    TResult Function(ToggleActive value)? toggleActive,
    TResult Function(ProcessRecurring value)? processRecurring,
    required TResult orElse(),
  }) {
    if (processRecurring != null) {
      return processRecurring(this);
    }
    return orElse();
  }
}

abstract class ProcessRecurring implements RecurringEvent {
  const factory ProcessRecurring() = _$ProcessRecurringImpl;
}
